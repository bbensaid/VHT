"use client";

import { useState, useRef, useEffect } from "react";
import { Slider } from "@/components/ui/slider";
import { Button } from "@/components/ui/button";
import {
  Play,
  Pause,
  SkipBack,
  SkipForward,
  Volume2,
  VolumeX,
  Download,
  Heart,
} from "lucide-react";
import { cn } from "@/lib/utils";

interface AudioPlayerProps {
  src: string;
  title: string;
  episodeId: string;
  onDownload?: () => void;
  onLike?: () => void;
  onEnded?: () => void;
  onError?: (error: Error) => void;
  className?: string;
}

export function AudioPlayer({
  src,
  title,
  episodeId,
  onEnded,
  onError,
  onDownload,
  onLike,
  className,
}: AudioPlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [progress, setProgress] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const audioRef = useRef<HTMLAudioElement>(null);
  const intervalRef = useRef<NodeJS.Timeout | undefined>(undefined);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    // Validate src
    if (!src) {
      console.error('Audio source URL is empty');
      onError?.(new Error('No audio source provided'));
      return;
    }

    // Reset player state when src changes
    setIsPlaying(false);
    setProgress(0);
    setDuration(0);

    // Set source
    audio.src = src;

    const handleLoadedMetadata = () => {
      if (!Number.isFinite(audio.duration)) {
        onError?.(new Error('Invalid audio duration'));
        return;
      }
      setDuration(audio.duration);
    };

    const handleAudioError = (event: ErrorEvent) => {
      const audio = audioRef.current;
      if (!audio) return;
      
      const errorDetails = {
        code: audio.error?.code,
        message: audio.error?.message,
        details: {
          currentSrc: audio.currentSrc || src,
          networkState: audio.networkState,
          readyState: audio.readyState,
          event: event.type
        }
      };
      console.error('Audio error details:', errorDetails);
      
      setIsPlaying(false);
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }

      let errorMessage = 'Failed to load or play the audio file';
      if (audio.error?.code === 2) {
        errorMessage = 'Network error while loading audio';
      } else if (audio.error?.code === 3) {
        errorMessage = 'Error decoding audio file';
      } else if (audio.error?.code === 4) {
        errorMessage = 'Audio source not supported';
      }

      onError?.(new Error(`${errorMessage} (code: ${audio.error?.code || 'unknown'})`));
    };

    const handleEnded = () => {
      setIsPlaying(false);
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      onEnded?.();
    };

    // Configure audio element
    audio.preload = "metadata";
    audio.crossOrigin = "anonymous"; // Enable CORS for audio loading
    
    // Reset the audio element
    audio.pause();
    audio.currentTime = 0;
    audio.load();

    // Add event listeners
    const events = {
      loadedmetadata: handleLoadedMetadata,
      ended: handleEnded,
      error: handleAudioError,
      abort: () => onError?.(new Error('Audio loading aborted')),
      stalled: () => console.warn('Audio loading stalled')
    };

    Object.entries(events).forEach(([event, handler]) => {
      audio.addEventListener(event, handler as EventListener);
    });

    // Clean up function to remove all event listeners
    return () => {
      Object.entries(events).forEach(([event, handler]) => {
        audio.removeEventListener(event, handler as EventListener);
      });
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
    audio.addEventListener("ended", handleEnded);
    audio.addEventListener("error", handleAudioError);

    return () => {
      const audio = audioRef.current;
      if (!audio) return;
      
      Object.entries(events).forEach(([event, handler]) => {
        audio.removeEventListener(event, handler as EventListener);
      });
      
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [onEnded, onError, src]);

  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  const startTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }

    intervalRef.current = setInterval(() => {
      if (audioRef.current?.ended) {
        setIsPlaying(false);
        clearInterval(intervalRef.current);
      } else {
        setProgress(audioRef.current?.currentTime || 0);
      }
    }, 1000);
  };

  const togglePlay = async () => {
    if (!audioRef.current) return;

    try {
      if (isPlaying) {
        audioRef.current.pause();
        if (intervalRef.current) {
          clearInterval(intervalRef.current);
        }
      } else {
        await audioRef.current.play();
        startTimer();
      }
      setIsPlaying(!isPlaying);
    } catch (error) {
      console.error('Playback error:', error);
      onError?.(new Error('Failed to play audio. Please check your connection and try again.'));
    }
  };

  const skipBackward = () => {
    if (!audioRef.current) return;
    audioRef.current.currentTime = Math.max(audioRef.current.currentTime - 10, 0);
    setProgress(audioRef.current.currentTime);
  };

  const skipForward = () => {
    if (!audioRef.current) return;
    audioRef.current.currentTime = Math.min(
      audioRef.current.currentTime + 10,
      duration
    );
    setProgress(audioRef.current.currentTime);
  };

  const toggleMute = () => {
    if (!audioRef.current) return;
    audioRef.current.muted = !isMuted;
    setIsMuted(!isMuted);
  };

  const handleVolumeChange = (value: number[]) => {
    if (!audioRef.current) return;
    const newVolume = value[0];
    audioRef.current.volume = newVolume;
    setVolume(newVolume);
  };

  const handleProgressChange = (value: number[]) => {
    if (!audioRef.current) return;
    const newTime = value[0];
    audioRef.current.currentTime = newTime;
    setProgress(newTime);
  };

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, "0")}`;
  };

  return (
    <div
      className={cn(
        "w-full p-4 rounded-lg border bg-card text-card-foreground shadow-sm",
        className
      )}
    >
      <audio 
        ref={audioRef} 
        src={src} 
        preload="metadata"
        crossOrigin="anonymous"
        onError={(e) => {
          console.error('Audio element error:', e);
          onError?.(new Error('Failed to load audio source'));
        }}
      />

      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="font-medium">{title}</h3>
          <div className="flex items-center gap-2">
            {onDownload && (
              <Button
                variant="ghost"
                size="icon"
                onClick={onDownload}
                title="Download episode"
              >
                <Download className="h-4 w-4" />
              </Button>
            )}
            {onLike && (
              <Button
                variant="ghost"
                size="icon"
                onClick={onLike}
                title="Like episode"
              >
                <Heart className="h-4 w-4" />
              </Button>
            )}
          </div>
        </div>

        <div className="space-y-2">
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground min-w-[40px]">
              {formatTime(progress)}
            </span>
            <Slider
              value={[progress]}
              max={duration}
              step={1}
              onValueChange={handleProgressChange}
              className="flex-1"
            />
            <span className="text-sm text-muted-foreground min-w-[40px]">
              {formatTime(duration)}
            </span>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Button
                variant="ghost"
                size="icon"
                onClick={toggleMute}
                title={isMuted ? "Unmute" : "Mute"}
              >
                {isMuted ? (
                  <VolumeX className="h-4 w-4" />
                ) : (
                  <Volume2 className="h-4 w-4" />
                )}
              </Button>
              <Slider
                value={[isMuted ? 0 : volume]}
                max={1}
                step={0.1}
                onValueChange={handleVolumeChange}
                className="w-[100px]"
              />
            </div>

            <div className="flex items-center gap-2">
              <Button
                variant="ghost"
                size="icon"
                onClick={skipBackward}
                title="Skip backward 10 seconds"
              >
                <SkipBack className="h-4 w-4" />
              </Button>
              <Button
                variant="default"
                size="icon"
                onClick={togglePlay}
                title={isPlaying ? "Pause" : "Play"}
              >
                {isPlaying ? (
                  <Pause className="h-4 w-4" />
                ) : (
                  <Play className="h-4 w-4" />
                )}
              </Button>
              <Button
                variant="ghost"
                size="icon"
                onClick={skipForward}
                title="Skip forward 10 seconds"
              >
                <SkipForward className="h-4 w-4" />
              </Button>
            </div>

            <div className="w-[132px]" /> {/* Balance the layout */}
          </div>
        </div>
      </div>
    </div>
  );
}